/* Generated by Together */
//#include "simplexy.h"
#include "pcfpreprocessor.h"


CPCFPreProcessor::CPCFPreProcessor()
{
	central_hole.X(0.);
	central_hole.Y(0.);
	is_complete_geometry = false;
	has_boundary_lines = true;
	has_pml_lines = false;
    pitch.X(0.);
	pitch.Y(0.);
	material = -1; //indice da lista completa de materiais
	
	d1 = 0;
	d2 = 0;
	d3 = 0;
	d4 = 0;

	mat_r1 = -1;
	mat_r2 = -1;
	mat_r3 = -1;
	mat_r4 = -1;
  
	ind_color = 0;
	
	vpcfLayers.clear();

}

CPCFPreProcessor::~CPCFPreProcessor()
{

}

void CPCFPreProcessor::Associate(CLevGeoData * pm)
{
	pModel = pm;
}

void CPCFPreProcessor::Associate(CLevPhysData * pphys)
{
	pPhysData = pphys;
	
}


void CPCFPreProcessor::IdentifyRefinedElementsToRegions()
{ }


void CPCFPreProcessor::GetLayersData(std::vector<CPCF_LayerData> &vl )
{
	unsigned int i;
	vl.clear();

	for(i=0;i<vpcfLayers.size();i++)
		vl.push_back(vpcfLayers[i].layer_data);
}


void CPCFPreProcessor::SetLayersData(std::vector<CPCF_LayerData> vl )
{
	unsigned int i;

	// Verifica se já existiam dados
	if(!vpcfLayers.size()) {
		CPCF_Layer olayer;

		// Inclui as camadas ainda sem os ponteiros para as elipses e linhas
		for(i=0;i<vl.size();i++) {
			olayer.layer_data = vl[i];
			vpcfLayers.push_back(olayer);
		}
	}
}


void CPCFPreProcessor::SetPitch(Point p)
{
	pitch = p;
}

Point CPCFPreProcessor::GetPitch(void)
{
	return pitch;
}

void CPCFPreProcessor::SetCentralHoleDiameters(Point c)
{
	central_hole = c;
}

Point CPCFPreProcessor::GetCentralHoleDiameters(void)
{
	return central_hole;
}

void CPCFPreProcessor::SetBackgroundMaterial(int m) //indice da lista completa de materiais
{
	material = m;
}

int CPCFPreProcessor::GetBackgroundMaterial(void)
{
	return material;
}

void CPCFPreProcessor::IsCompleteGeometry(bool b)
{
	//aqui é necessário colocar uma verificação de alteração
	is_complete_geometry = b;
}

bool CPCFPreProcessor::IsCompleteGeometry(void)
{
 return is_complete_geometry;
}

void CPCFPreProcessor::HasBoundaryLines(bool b)
{
	//aqui é necessário colocar uma verificação de alteração
	has_boundary_lines = b;

}
bool CPCFPreProcessor::HasBoundaryLines(void)
{
	return has_boundary_lines;
}

void CPCFPreProcessor::IncludeUpdateData(void)
{
	int pos_reg;
	CLevPoint opointref_reg;

	if(pModel)
	{
		background_region.Reinitialize();
		background_region_ext.Reinitialize();
		region_right.Reinitialize();
		region_left.Reinitialize();
		region_top.Reinitialize();
		region_down.Reinitialize();
		region_topright.Reinitialize();
		region_downright.Reinitialize();
		region_topleft.Reinitialize();
		region_downleft.Reinitialize();

		if(is_complete_geometry)
			IncludeUpdatePitchCompleteGeometry();
		else
			IncludeUpdatePitchQuarterGeometry();

		IncludeBoundaryLines();
		IncludePMLLines();
		
		if(material >=0)
		{
			pos_reg = pModel->IncludeRegion(background_region);
			opointref_reg.X(0);
			opointref_reg.Y(0);
			pPhysData->AssociateMaterialToRegion(pos_reg, material,opointref_reg, 0.0);

			if(has_boundary_lines)
			{
				pos_reg = pModel->IncludeRegion(background_region_ext);
				opointref_reg.X(0);
				opointref_reg.Y(0);
				pPhysData->AssociateMaterialToRegion(pos_reg, material,opointref_reg, 0.0);
			}

			if(has_pml_lines)
			{
				pos_reg = pModel->IncludeRegion(region_right);
				opointref_reg.X(0);
				opointref_reg.Y(0);
				pPhysData->AssociateMaterialToRegion(pos_reg, material,opointref_reg, 0.0);

				pos_reg = pModel->IncludeRegion(region_top);
				opointref_reg.X(0);
				opointref_reg.Y(0);
				pPhysData->AssociateMaterialToRegion(pos_reg, material,opointref_reg, 0.0);

				pos_reg = pModel->IncludeRegion(region_topright);
				opointref_reg.X(0);
				opointref_reg.Y(0);
				pPhysData->AssociateMaterialToRegion(pos_reg, material,opointref_reg, 0.0);

				if(is_complete_geometry)
				{
					pos_reg = pModel->IncludeRegion(region_left);
					opointref_reg.X(0);
					opointref_reg.Y(0);
					pPhysData->AssociateMaterialToRegion(pos_reg, material,opointref_reg, 0.0);

					pos_reg = pModel->IncludeRegion(region_down);
					opointref_reg.X(0);
					opointref_reg.Y(0);
					pPhysData->AssociateMaterialToRegion(pos_reg, material,opointref_reg, 0.0);

					pos_reg = pModel->IncludeRegion(region_topleft);
					opointref_reg.X(0);
					opointref_reg.Y(0);
					pPhysData->AssociateMaterialToRegion(pos_reg, material,opointref_reg, 0.0);

					pos_reg = pModel->IncludeRegion(region_downleft);
					opointref_reg.X(0);
					opointref_reg.Y(0);
					pPhysData->AssociateMaterialToRegion(pos_reg, material,opointref_reg, 0.0);

					pos_reg = pModel->IncludeRegion(region_downright);
					opointref_reg.X(0);
					opointref_reg.Y(0);
					pPhysData->AssociateMaterialToRegion(pos_reg, material,opointref_reg, 0.0);
				}
			}
		}
	}
}


void CPCFPreProcessor::IncludeUpdatePitchQuarterGeometry(void)
{
	unsigned int    ii;
	int				i,j,pos, pos_reg;
	int				num_camadas, num_sub_camadas, num_camadas_anterior;
	int				num_predis_points, num_predis_points_half;
	double			deltax,deltay,centerx, centery, centerx1, centery1;
	double			xaxis, yaxis;	
	double			resto;
	CLevPoint		opointref;// "ponto clicado" para os dados de pré-discretização
	CLevPoint		opointref_reg;//ponto que "identifica" uma região
	double			coeficiente_angular=0, coeficiente_linear;
	double			diametro_ultima_camada;
	CLevLine		oline;
	vpCLevPoint		vpp;
	CLevEllipse		o_elipse;
	CLevLine		o_line;
	CLevRegion		o_region_holes;
	long			mat_index;
	int p;

	opointref.X(0.);
	opointref.Y(0.);

	deltax = pitch.X();
	deltay = pitch.Y();

	vpPointsX.clear();
	vpPointsY.clear();
	
	xcmax = 0;
	ycmax_of_xcmax = 0;

	pcentral.X(0);
	pcentral.Y(0);

	vpHoles.clear();
	vpBoundaryLines.clear();

	if(!is_complete_geometry)
		ppcentral = pModel->Include(pcentral);

	if(central_hole.X() && central_hole.Y()) {
		o_region_holes.Reinitialize();

		num_predis_points = vpcfLayers[0].layer_data.PredisPoints();
		pos = pModel->Include(0.0,0.0,central_hole.X(),central_hole.Y(),0.0,90.0);
		if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
			if(num_predis_points/4 > 3) num_predis_points_half = num_predis_points/4;
			else num_predis_points_half = 4;
			
			pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);
			o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			vpPointsX.push_back(pModel->GetPrimitive(pos)->vpPoints[0]);
			vpPointsY.push_back(pModel->GetPrimitive(pos)->vpPoints[1]);		
			
			//inserção das linhas 
			vpp.clear();
			vpp.push_back(ppcentral);
			vpp.push_back(vpPointsY[0]);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);
			o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			vpp.clear();
			vpp.push_back(ppcentral);
			vpp.push_back(vpPointsX[0]);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);
			o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			mat_index = vpcfLayers[0].layer_data.Material();

			if(mat_index < 0)
				for(ii=0; ii<vpcfLayers.size() && mat_index<0; ii++)
					mat_index = vpcfLayers[ii].layer_data.Material();

			if(mat_index >= 0) {
				pos_reg = pModel->IncludeRegion(o_region_holes);
				opointref_reg.X(0);
				opointref_reg.Y(0);
				pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
			}
		}
	}

	num_camadas_anterior = 0;
	//para todas as camadas
	num_camadas = vpcfLayers.size();
	for(p=0;p<num_camadas;p++) {
		xaxis = vpcfLayers[p].layer_data.diameters.X()/2.;
		yaxis = vpcfLayers[p].layer_data.diameters.Y()/2.;
		num_sub_camadas = vpcfLayers[p].layer_data.SubLayersNumber();
		num_predis_points = vpcfLayers[p].layer_data.PredisPoints();

		mat_index = vpcfLayers[p].layer_data.Material();

		for(i=1;i<=num_sub_camadas;i++)	{
			centerx = (num_camadas_anterior+i)*deltax;
			centery = (num_camadas_anterior+i)*deltay;

			//se algum diametro x ou y for zero: não inclui os furos, mas desloca as
			// outras camadas como se existisse uma camada sem furos
			if(xaxis>0 && yaxis>0) {
				pos = pModel->Include(centerx,centery,xaxis,yaxis,0.0,0.0);
				if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
					o_region_holes.Reinitialize();
					o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					if(mat_index >= 0) {
						pos_reg = pModel->IncludeRegion(o_region_holes);
						opointref_reg.X(centerx);
						opointref_reg.Y(centery);
						pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
					}

					pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);
					
					xcmax= centerx;
					ycmax_of_xcmax= centery;
				}
			} else {
				xcmax= centerx;
				ycmax_of_xcmax= centery;
			}

			for(j=1;j<=(num_camadas_anterior+i);j++) {
				centerx = ((num_camadas_anterior+i)*deltax) - (j* (deltax));
				centery = (num_camadas_anterior+i)*deltay + j* deltay ; 

				if(centerx == 0.0) {
					if(xaxis > 0 && yaxis > 0) {
						pos = pModel->Include(centerx,centery,xaxis,yaxis,270.0,90.0);
						if(pos >= 0 && pos < (signed)pModel->vpPrimitives.size()) {
							num_predis_points_half = num_predis_points;
							pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);
							o_region_holes.Reinitialize();
							o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));

							vpp.clear();
							vpp.push_back(pModel->GetPrimitive(pos)->vpPoints[0]);
							vpp.push_back(pModel->GetPrimitive(pos)->vpPoints[1]);
							oline.SetPoints(vpp);
							pos = pModel->Include(oline);
							if(pos >= 0 && pos < (signed)pModel->vpPrimitives.size()) {
								vpPointsY.push_back(pModel->GetPrimitive(pos)->vpPoints[0]);
								vpPointsY.push_back(pModel->GetPrimitive(pos)->vpPoints[1]);
								pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);						
								o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
														
								if(mat_index >= 0) {
									pos_reg = pModel->IncludeRegion(o_region_holes);
									opointref_reg.X(centerx);
									opointref_reg.Y(centery);
									pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
								}

								if(centery > ycmax)
									ycmax = centery;
							}						
						}
					} else {
						if(centery > ycmax)
							ycmax = centery;
					}
				} else {
					if(xaxis > 0 && yaxis > 0) {
						pos = pModel->Include(centerx,centery,xaxis,yaxis,0.0,0.0);
						if(pos >= 0 && pos < (signed)pModel->vpPrimitives.size()) {
							pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);
							o_region_holes.Reinitialize();
							o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							if(mat_index >= 0) {
								pos_reg = pModel->IncludeRegion(o_region_holes);
								opointref_reg.X(centerx);
								opointref_reg.Y(centery);
								pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
							}
							if(centerx > xcmax && centery > ycmax_of_xcmax) {
								xcmax= centerx;
								ycmax_of_xcmax= centery;
							}	
						}
					} else {
						if(centerx > xcmax && centery > ycmax_of_xcmax) {
							xcmax= centerx;
							ycmax_of_xcmax= centery;
						}	
					}
				}

				centerx1 = ((num_camadas_anterior+i)*deltax);
				centery1 = ((num_camadas_anterior+i)*deltay)- ((2*j)* deltay);

				resto = (num_camadas_anterior+i)%2;
				if (centery1 == 0.0 && resto==0.0) // furos na horizontal
				{
					if(xaxis > 0 && yaxis >0 )
					{
						pos = pModel->Include(centerx1,centery1,xaxis,yaxis,0.0,180.0);
						if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
							num_predis_points_half=num_predis_points;
							pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);
							o_region_holes.Reinitialize();
							o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));

							vpPointsX.push_back(pModel->GetPrimitive(pos)->vpPoints[1]);
							vpPointsX.push_back(pModel->GetPrimitive(pos)->vpPoints[0]);

							vpp.clear();
							vpp.push_back(pModel->GetPrimitive(pos)->vpPoints[0]);
							vpp.push_back(pModel->GetPrimitive(pos)->vpPoints[1]);
							oline.SetPoints(vpp);
							pos = pModel->Include(oline);
							if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
								pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);
								o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
														
								if(mat_index >=0) {
									pos_reg = pModel->IncludeRegion(o_region_holes);
									opointref_reg.X(centerx);
									opointref_reg.Y(centery);
									pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
								}
							}						
						}
					}
				}

				if(centery1 != 0.0 && centery1> 0.0) {
					if(xaxis > 0 && yaxis > 0) {
						pos = pModel->Include(centerx1,centery1,xaxis,yaxis,0.0,0.0);
						pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);					
						if(pos >= 0 && pos < (signed)pModel->vpPrimitives.size()) {
							o_region_holes.Reinitialize();
							o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							if(mat_index >= 0) {
								pos_reg = pModel->IncludeRegion(o_region_holes);
								opointref_reg.X(centerx);
								opointref_reg.Y(centery);
								pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
							}
						}
											
						if(centerx > xcmax && centery > ycmax_of_xcmax) {
							xcmax= centerx1;
							ycmax_of_xcmax= centery1;
						}
					} else {
						if(centerx > xcmax && centery > ycmax_of_xcmax) {
							xcmax= centerx1;
							ycmax_of_xcmax= centery1;
						}
					}
				}
			}
		}
		num_camadas_anterior = num_camadas_anterior + num_sub_camadas;
	}

	//insere linhas 
	diametro_ultima_camada = vpcfLayers[vpcfLayers.size()-1].layer_data.diameters.X();
	//calcula ponto extremo ymax em x=0

	if(has_boundary_lines || !d1 || (!d1&&!d2))
		xmax = xcmax + 3*diametro_ultima_camada/4;
	else 
		xmax = xcmax + diametro_ultima_camada/2;

	ymax = ycmax + diametro_ultima_camada/2+ diametro_ultima_camada/4;

	//coeficiente angular da reta que passa pelos centros dos furos da ultima camada
	coeficiente_angular = (ycmax - ycmax_of_xcmax)/(- xcmax);
	coeficiente_linear = ymax;
	ymax_of_xmax = coeficiente_angular*xmax + coeficiente_linear;
}


void CPCFPreProcessor::IncludeUpdatePitchCompleteGeometry(void)
{
	unsigned int    ii;
	int				i,j,pos, pos_reg;
	int				num_camadas, num_sub_camadas, num_camadas_anterior;
	int				num_predis_points;
	double			deltax,deltay,centerx, centery, centerx1, centery1;
	double			xaxis, yaxis;	
	double			resto;
	CLevPoint		opointref;// "ponto clicado" para os dados de pré-discretização
	CLevPoint		opointref_reg;//ponto que "identifica" uma região
	double			coeficiente_angular=0, coeficiente_linear;
	double			diametro_ultima_camada;
	CLevLine		oline;
	vpCLevPoint		vpp;
	CLevEllipse		o_elipse, *po_elipse;
	CLevLine		o_line;
	CLevRegion		o_region_holes;
	long			mat_index = -1;
	int p;

	opointref.X(0.);
	opointref.Y(0.);

	deltax = pitch.X();
	deltay = pitch.Y();

	vpPointsX.clear();
	vpPointsY.clear();
	
	xcmax = 0;
	ycmax_of_xcmax = 0;

	pcentral.X(0);
	pcentral.Y(0);

	vpHoles.clear();
	vpBoundaryLines.clear();

	if(!is_complete_geometry)
		ppcentral = pModel->Include(pcentral);

	if(central_hole.X() && central_hole.Y()) {
		num_predis_points = vpcfLayers[0].layer_data.PredisPoints();
		pos = pModel->Include(0.0,0.0,central_hole.X()/2,central_hole.Y()/2,0.0,0.0);
		if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
			pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);

			o_region_holes.Reinitialize();
			o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			mat_index = vpcfLayers[0].layer_data.Material();
			if(mat_index < 0)
				for(ii=0; ii<vpcfLayers.size() && mat_index<0; ii++)
					mat_index = vpcfLayers[ii].layer_data.Material();

			if(mat_index >= 0) {
				pos_reg = pModel->IncludeRegion(o_region_holes);
				opointref_reg.X(0);
				opointref_reg.Y(0);
				pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
			}
		}
	}

	num_camadas_anterior = 0;

	// Para todas as camadas
	num_camadas = vpcfLayers.size();
	for(p=0;p<num_camadas;p++) {
		xaxis = vpcfLayers[p].layer_data.diameters.X()/2.;
		yaxis = vpcfLayers[p].layer_data.diameters.Y()/2.;
		num_sub_camadas = vpcfLayers[p].layer_data.SubLayersNumber();
		num_predis_points = vpcfLayers[p].layer_data.PredisPoints();

		mat_index = vpcfLayers[p].layer_data.Material();

		for(i=1;i<=num_sub_camadas;i++)	{
			centerx = (num_camadas_anterior+i)*deltax;
			centery = (num_camadas_anterior+i)*deltay;

			if(xaxis && yaxis) {
				pos = pModel->Include(centerx,centery,xaxis,yaxis,0.0,0.0);
				if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
					o_region_holes.Reinitialize();
					o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					if(mat_index >= 0) {
						pos_reg = pModel->IncludeRegion(o_region_holes);
						opointref_reg.X(centerx);
						opointref_reg.Y(centery);
						pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
					}

					pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);
					po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
					o_elipse = *po_elipse;
					
					//cópia por reflexao em y (para desenhar o 2 quadrante)
					pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
					if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >= 0) {
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}
					}

					//cópia por reflexao em x (para desenhar o 4 quadrante)
					pos = pModel->CreateByReflection(o_elipse, REFLECTIONXAXIS,opointref, opointref);
					if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >= 0) {
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}
					}

					//cópia por reflexao em y (para desenhar o 3 quadrante)
					po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
					o_elipse = *po_elipse;				
					pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
					if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >= 0) {
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}
					}
					
				}
			}

			xcmax= centerx;
			ycmax_of_xcmax= centery;
		
			for(j=1;j<=(num_camadas_anterior+i);j++) {
				centerx = ((num_camadas_anterior+i)*deltax) - (j* (deltax));
				centery = (num_camadas_anterior+i)*deltay + j* deltay ; 

				// Furos na vertical
				if(centerx == 0.0) {
					if(xaxis && yaxis) {
						pos = pModel->Include(centerx,centery,xaxis,yaxis,0.0,0.0);
						if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
							pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);
							o_region_holes.Reinitialize();
							o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							if(mat_index >= 0) {
								pos_reg = pModel->IncludeRegion(o_region_holes);
								opointref_reg.X(centerx);
								opointref_reg.Y(centery);
								pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
							}

							po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
							o_elipse = *po_elipse;				

							//cópia por reflexao em x 
							pos = pModel->CreateByReflection(o_elipse, REFLECTIONXAXIS,opointref, opointref);
							if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
								o_region_holes.Reinitialize();
								o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								if(mat_index >= 0) {
									pos_reg = pModel->IncludeRegion(o_region_holes);
									opointref_reg.X(centerx);
									opointref_reg.Y(centery);
									pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
								}
							}
						}
					}
					
					if(centery > ycmax)
						ycmax = centery;

				} else {
					if(xaxis && yaxis) {
						pos = pModel->Include(centerx,centery,xaxis,yaxis,0.0,0.0);
						if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
							pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);
							o_region_holes.Reinitialize();
							o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							if(mat_index >=0) {
								pos_reg = pModel->IncludeRegion(o_region_holes);
								opointref_reg.X(centerx);
								opointref_reg.Y(centery);
								pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
							}
							if(centerx > xcmax && centery > ycmax_of_xcmax) {
								xcmax= centerx;
								ycmax_of_xcmax= centery;
							}

							po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
							o_elipse = *po_elipse;				

							//cópia por reflexao em y (para desenhar o 2 quadrante)
							pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
							if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
								o_region_holes.Reinitialize();
								o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								if(mat_index >=0) {
									pos_reg = pModel->IncludeRegion(o_region_holes);
									opointref_reg.X(centerx);
									opointref_reg.Y(centery);
									pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
								}
							}

							//cópia por reflexao em x (para desenhar o 4 quadrante)
							pos = pModel->CreateByReflection(o_elipse, REFLECTIONXAXIS,opointref, opointref);
							if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
								o_region_holes.Reinitialize();
								o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								if(mat_index >=0) {
									pos_reg = pModel->IncludeRegion(o_region_holes);
									opointref_reg.X(centerx);
									opointref_reg.Y(centery);
									pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
								}
							}
							//cópia por reflexao em y (para desenhar o 3 quadrante)
							po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
							o_elipse = *po_elipse;				
							pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
							if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
								o_region_holes.Reinitialize();
								o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								if(mat_index >=0) {
									pos_reg = pModel->IncludeRegion(o_region_holes);
									opointref_reg.X(centerx);
									opointref_reg.Y(centery);
									pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
								}
							}
						}
					} else {
						if(centerx > xcmax && centery > ycmax_of_xcmax) {
							xcmax = centerx;
							ycmax_of_xcmax = centery;
						}
					}
				}

				centerx1 = ((num_camadas_anterior+i)*deltax);
				centery1 = ((num_camadas_anterior+i)*deltay)- ((2*j)* deltay);

				resto = (num_camadas_anterior+i)%2;
				if (centery1 == 0.0 && resto==0.0) // furos na horizontal
				{
					if(xaxis && yaxis)
					{
						pos = pModel->Include(centerx1,centery1,xaxis,yaxis,0.0,0.0);
						if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
							pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);
							o_region_holes.Reinitialize();
							o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							if(mat_index >= 0) {
								pos_reg = pModel->IncludeRegion(o_region_holes);
								opointref_reg.X(centerx);
								opointref_reg.Y(centery);
								pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
							}
							po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
							o_elipse = *po_elipse;				

							//cópia por reflexao em y 
							pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
							if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
								o_region_holes.Reinitialize();
								o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								if(mat_index >= 0) {
									pos_reg = pModel->IncludeRegion(o_region_holes);
									opointref_reg.X(centerx);
									opointref_reg.Y(centery);
									pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
								}
							}
						}
					}

				}

				if(centery1 != 0.0 && centery1> 0.0) {
					if(xaxis && yaxis) {
						pos = pModel->Include(centerx1,centery1,xaxis,yaxis,0.0,0.0);
						if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
							pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);					
							o_region_holes.Reinitialize();
							o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
							if(mat_index >=0) {
								pos_reg = pModel->IncludeRegion(o_region_holes);
								opointref_reg.X(centerx);
								opointref_reg.Y(centery);
								pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
							}
							if(centerx > xcmax && centery > ycmax_of_xcmax) {
								xcmax= centerx1;
								ycmax_of_xcmax= centery1;
							}

							po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
							o_elipse = *po_elipse;				

							//cópia por reflexao em y (para desenhar o 2 quadrante)
							pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
							if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
								o_region_holes.Reinitialize();
								o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								if(mat_index >= 0) {
									pos_reg = pModel->IncludeRegion(o_region_holes);
									opointref_reg.X(centerx);
									opointref_reg.Y(centery);
									pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
								}
							}

							//cópia por reflexao em x (para desenhar o 4 quadrante)
							pos = pModel->CreateByReflection(o_elipse, REFLECTIONXAXIS,opointref, opointref);
							if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
								o_region_holes.Reinitialize();
								o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								if(mat_index >=0) {
									pos_reg = pModel->IncludeRegion(o_region_holes);
									opointref_reg.X(centerx);
									opointref_reg.Y(centery);
									pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
								}
							}

							//cópia por reflexao em y (para desenhar o 3 quadrante)
							po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
							o_elipse = *po_elipse;				
							pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
							if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
								o_region_holes.Reinitialize();
								o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
								if(mat_index >=0) {
									pos_reg = pModel->IncludeRegion(o_region_holes);
									opointref_reg.X(centerx);
									opointref_reg.Y(centery);
									pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
								}
							}
						}
					} else {
						if(centerx > xcmax && centery > ycmax_of_xcmax) {
							xcmax= centerx1;
							ycmax_of_xcmax= centery1;
						}
					}
				}
			}
		}
		num_camadas_anterior = num_camadas_anterior + num_sub_camadas;
	}

	// Insere linhas
	diametro_ultima_camada = vpcfLayers[vpcfLayers.size()-1].layer_data.diameters.X();
	// Calcula ponto extremo ymax em x=0

	if(has_boundary_lines || !d1 || (!d1&&!d2))
		xmax = xcmax + 3*diametro_ultima_camada/4;
	else 
		xmax = xcmax + diametro_ultima_camada/2;

	if(has_boundary_lines || !d3 || (!d3&&!d4))
		ymax = ycmax + diametro_ultima_camada/2+ diametro_ultima_camada/4;
	else 
		ymax = ycmax +  diametro_ultima_camada/2;

	//coeficiente angular da reta que passa pelos centros dos furos da ultima camada
	coeficiente_angular = (ycmax - ycmax_of_xcmax)/(- xcmax);
	coeficiente_linear = ymax;
	ymax_of_xmax = coeficiente_angular*xmax + coeficiente_linear;
}


void CPCFPreProcessor::IncludeBoundaryLines(void)
{
	unsigned int    i;
	int				pos;
	CLevPoint		px0ymax, pxmaxy0, pxmaxyofxmax;
	vpCLevPoint		vpp;
	CLevLine		oline;
	CLevPoint		opointref;// "ponto clicado" para os dados de pré-discretização
	CLevLine		o_line, *po_line;


	if(has_boundary_lines || !is_complete_geometry) {
		px0ymax.X(0);
		px0ymax.Y(ymax);
		ppx0ymax = pModel->Include(px0ymax);

		pxmaxy0.X(xmax);
		pxmaxy0.Y(0);
		ppxmaxy0= pModel->Include(pxmaxy0);
	}

	if(has_boundary_lines) {
		pxmaxyofxmax.X(xmax);
		pxmaxyofxmax.Y(ymax_of_xmax);
		ppxmaxyofxmax= pModel->Include(pxmaxyofxmax);
	}

	if(!is_complete_geometry) {
		//-----------------inclusão das linhas verticais (x=0) -------------------
		int inic = 1;
		if(central_hole.X() && central_hole.Y()) {
			inic = 0;
		} else {
			vpp.clear();
			vpp.push_back(&pcentral);
			vpp.push_back(vpPointsY[0]);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			if(pos >=0 && pos < (signed)pModel->vpPrimitives.size())
				background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
		}

		for(i=inic;i<vpPointsY.size()-1;i=i+2) {
			vpp.clear();
			vpp.push_back(vpPointsY[i]);
			vpp.push_back(vpPointsY[i+1]);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			if(pos >=0 && pos < (signed)pModel->vpPrimitives.size())
				background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
		}

		if (i >= vpPointsY.size())
			i = vpPointsY.size() - 1;
		vpp.clear();
		vpp.push_back(vpPointsY[i]);
		vpp.push_back(ppx0ymax);
		oline.SetPoints(vpp);
		pos = pModel->Include(oline);
		if(pos >=0 && pos < (signed)pModel->vpPrimitives.size())
			background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));

		//-----------------inclusão das linhas horizontais (y=0) -------------------
		if(vpPointsX.size()) {
			if(central_hole.X() && central_hole.Y()) {
				inic = 0;
			} else {
				vpp.clear();
				vpp.push_back(&pcentral);
				vpp.push_back(vpPointsX[0]);
				oline.SetPoints(vpp);
				pos = pModel->Include(oline);
				if(pos >=0 && pos < (signed)pModel->vpPrimitives.size())
					background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			}

			for(i=inic;i<vpPointsX.size()-1;i=i+2) {
				vpp.clear();
				vpp.push_back(vpPointsX[i]);
				vpp.push_back(vpPointsX[i+1]);
				oline.SetPoints(vpp);
				pos = pModel->Include(oline);
				if(pos >=0 && pos < (signed)pModel->vpPrimitives.size())
					background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			}

			if (i >= vpPointsX.size())
				i = vpPointsX.size() - 1;
			vpp.clear();
			vpp.push_back(vpPointsX[i]);
			vpp.push_back(ppxmaxy0);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			if(pos >=0 && pos < (signed)pModel->vpPrimitives.size())
				background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
		} else {
			vpp.clear();
			vpp.push_back(&pcentral);
			vpp.push_back(ppxmaxy0);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
		}

	}//if(!is_complete_geometry)


	if(has_boundary_lines)
	{
		//-----------------inclusão da linha vertical (x=xmax) -------------------
		vpp.clear();
		vpp.push_back(ppxmaxy0);
		vpp.push_back(ppxmaxyofxmax);
		oline.SetPoints(vpp);
		pos = pModel->Include(oline);
		background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
		background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));

		if(is_complete_geometry)
		{
			po_line = (CLevLine *)pModel->GetPrimitive(pos);
			o_line = *po_line;				

			//cópia por reflexao em y (para desenhar o 2 quadrante)
			pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
			background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			//cópia por reflexao em x (para desenhar o 4 quadrante)
			pos = pModel->CreateByReflection(o_line, REFLECTIONXAXIS,opointref, opointref);
			background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			//cópia por reflexao em y (para desenhar o 3 quadrante)
			po_line = (CLevLine *)pModel->GetPrimitive(pos);
			o_line = *po_line;				
			pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
			background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));

		}


		//-----------------inclusão da linha inclinada -------------------
		vpp.clear();
		vpp.push_back(ppxmaxyofxmax);
		vpp.push_back(ppx0ymax);
		oline.SetPoints(vpp);
		pos = pModel->Include(oline);
		background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
		background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));

		if(is_complete_geometry)
		{
			po_line = (CLevLine *)pModel->GetPrimitive(pos);
			o_line = *po_line;				

			//cópia por reflexao em y (para desenhar o 2 quadrante)
			pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
			background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			//cópia por reflexao em x (para desenhar o 4 quadrante)
			pos = pModel->CreateByReflection(o_line, REFLECTIONXAXIS,opointref, opointref);
			background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			//cópia por reflexao em y (para desenhar o 3 quadrante)
			po_line = (CLevLine *)pModel->GetPrimitive(pos);
			o_line = *po_line;				
			pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
			background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));
		}
		
	}//if(has_boundary_lines)

}//void CPCFPreProcessor::IncludeBoundaryLines(void)

void CPCFPreProcessor::IncludePMLLines(void)
{
	int				pos;

	CLevLine		oline;
	vpCLevPoint		vpp;
	CLevLine		o_line, *po_line;
	CLevPoint		opointref;// "ponto clicado" para os dados de pré-discretização

	if(has_pml_lines)
	{
		CLevPoint pd1,pd2,pd3,pd4, pd1d3, pd1d4, pd2d3, pd2d4;
		CLevPoint *ppd1,*ppd2,*ppd3,*ppd4, *ppd1d3, *ppd1d4, *ppd2d3, *ppd2d4;

		// pd1 (y=0)
		pd1.X(xmax + d1);
		pd1.Y(0);
		ppd1 = pModel->Include(pd1);
		// pd2 (y=0)
		pd2.X(ppd1->X() + d2);
		pd2.Y(0);
		ppd2 = pModel->Include(pd2);
		// pd3 (x=0)
		pd3.X(0);
		pd3.Y(ymax + d3);
		ppd3 = pModel->Include(pd3);
		// pd4 (x=0)
		pd4.X(0);
		pd4.Y(ppd3->Y() + d4);
		ppd4 = pModel->Include(pd4);
		// pd1d3
		pd1d3.X(ppd1->X());
		pd1d3.Y(ppd3->Y());
		ppd1d3 = pModel->Include(pd1d3);
		//pd1d4
		pd1d4.X(ppd1->X());
		pd1d4.Y(ppd4->Y());
		ppd1d4 = pModel->Include(pd1d4);
		// pd2d3
		pd2d3.X(ppd2->X());
		pd2d3.Y(ppd3->Y());
		ppd2d3 = pModel->Include(pd2d3);
		// pd2d4
		pd2d4.X(ppd2->X());
		pd2d4.Y(ppd4->Y());
		ppd2d4 = pModel->Include(pd2d4);
		
	//inclusão das retas	
		vpp.clear();
		vpp.push_back(ppd1);
		vpp.push_back(ppd1d3);
		oline.SetPoints(vpp);
		pos = pModel->Include(oline);
		if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
			region_right.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			if(has_boundary_lines)
				background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			else
				background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			if(is_complete_geometry) {
				po_line = (CLevLine *)pModel->GetPrimitive(pos);
				if(po_line) {
					o_line = *po_line;				

					//cópia por reflexao em y (para desenhar o 2 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
			
					region_left.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					if(has_boundary_lines)
						background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					else
						background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em x (para desenhar o 4 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONXAXIS,opointref, opointref);
					region_right.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					if(has_boundary_lines)
						background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					else
						background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em y (para desenhar o 3 quadrante)
					po_line = (CLevLine *)pModel->GetPrimitive(pos);
					o_line = *po_line;				
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_left.IncludeNextPrimitive(pModel->GetPrimitive(pos));				
					if(has_boundary_lines)
						background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					else
						background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				}
			}
		}
		

		vpp.clear();
		vpp.push_back(ppd3);
		vpp.push_back(ppd1d3);
		oline.SetPoints(vpp);
		pos = pModel->Include(oline);
		if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
			region_top.IncludeNextPrimitive(pModel->GetPrimitive(pos));				
			if(has_boundary_lines)
				background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			else
				background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			if(is_complete_geometry) {
				po_line = (CLevLine *)pModel->GetPrimitive(pos);
				if(po_line) {
					o_line = *po_line;				

					//cópia por reflexao em y (para desenhar o 2 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_top.IncludeNextPrimitive(pModel->GetPrimitive(pos));				
					if(has_boundary_lines)
						background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					else
						background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em x (para desenhar o 4 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONXAXIS,opointref, opointref);
					region_down.IncludeNextPrimitive(pModel->GetPrimitive(pos));				
					if(has_boundary_lines)
						background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					else
						background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em y (para desenhar o 3 quadrante)
					po_line = (CLevLine *)pModel->GetPrimitive(pos);
					o_line = *po_line;				
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_down.IncludeNextPrimitive(pModel->GetPrimitive(pos));				
					if(has_boundary_lines)
						background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					else
						background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				}
			}
		}
		
		
		vpp.clear();
		vpp.push_back(ppd1d3);
		vpp.push_back(ppd1d4);
		oline.SetPoints(vpp);
		pos = pModel->Include(oline);
		if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
			region_top.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			region_topright.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			if(is_complete_geometry) {
				po_line = (CLevLine *)pModel->GetPrimitive(pos);
				if(po_line) {
					o_line = *po_line;				

					//cópia por reflexao em y (para desenhar o 2 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_top.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					region_topleft.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em x (para desenhar o 4 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONXAXIS,opointref, opointref);
					region_down.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					region_downright.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em y (para desenhar o 3 quadrante)
					po_line = (CLevLine *)pModel->GetPrimitive(pos);
					o_line = *po_line;				
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_down.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					region_downleft.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				}
			}
		}

		vpp.clear();
		vpp.push_back(ppd2);
		vpp.push_back(ppd2d3);
		oline.SetPoints(vpp);
		pos = pModel->Include(oline);
		if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
			region_right.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			if(is_complete_geometry) {
				po_line = (CLevLine *)pModel->GetPrimitive(pos);
				if(po_line) {
					o_line = *po_line;				

					//cópia por reflexao em y (para desenhar o 2 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_left.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em x (para desenhar o 4 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONXAXIS,opointref, opointref);
					region_right.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em y (para desenhar o 3 quadrante)
					po_line = (CLevLine *)pModel->GetPrimitive(pos);
					o_line = *po_line;				
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_left.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				}
			}
		}

		vpp.clear();
		vpp.push_back(ppd4);
		vpp.push_back(ppd1d4);
		oline.SetPoints(vpp);
		pos = pModel->Include(oline);
		if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
			region_top.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			if(is_complete_geometry) {
				po_line = (CLevLine *)pModel->GetPrimitive(pos);
				if(po_line) {
					o_line = *po_line;				

					//cópia por reflexao em y (para desenhar o 2 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_top.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em x (para desenhar o 4 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONXAXIS,opointref, opointref);
					region_down.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em y (para desenhar o 3 quadrante)
					po_line = (CLevLine *)pModel->GetPrimitive(pos);
					o_line = *po_line;				
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_down.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				}
			}
		}

		vpp.clear();
		vpp.push_back(ppd1d3);
		vpp.push_back(ppd2d3);
		oline.SetPoints(vpp);
		pos = pModel->Include(oline);
		if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
			region_right.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			region_topright.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			if(is_complete_geometry) {
				po_line = (CLevLine *)pModel->GetPrimitive(pos);
				if(po_line) {
					o_line = *po_line;				

					//cópia por reflexao em y (para desenhar o 2 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_left.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					region_topleft.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em x (para desenhar o 4 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONXAXIS,opointref, opointref);
					region_right.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					region_downright.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em y (para desenhar o 3 quadrante)
					po_line = (CLevLine *)pModel->GetPrimitive(pos);
					o_line = *po_line;				
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_left.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					region_downleft.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				}
			}
		}

		vpp.clear();
		vpp.push_back(ppd2d3);
		vpp.push_back(ppd2d4);
		oline.SetPoints(vpp);
		pos = pModel->Include(oline);
		if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
			region_topright.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			if(is_complete_geometry) {
				po_line = (CLevLine *)pModel->GetPrimitive(pos);
				if(po_line) {
					o_line = *po_line;				

					//cópia por reflexao em y (para desenhar o 2 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_topleft.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em x (para desenhar o 4 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONXAXIS,opointref, opointref);
					region_downright.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em y (para desenhar o 3 quadrante)
					po_line = (CLevLine *)pModel->GetPrimitive(pos);
					o_line = *po_line;				
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_downleft.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				}
			}
		}
		vpp.clear();
		vpp.push_back(ppd1d4);
		vpp.push_back(ppd2d4);
		oline.SetPoints(vpp);
		pos = pModel->Include(oline);
		if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
			region_topright.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			if(is_complete_geometry) {
				po_line = (CLevLine *)pModel->GetPrimitive(pos);
				if(po_line) {
					o_line = *po_line;				

					//cópia por reflexao em y (para desenhar o 2 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_topleft.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em x (para desenhar o 4 quadrante)
					pos = pModel->CreateByReflection(o_line, REFLECTIONXAXIS,opointref, opointref);
					region_downright.IncludeNextPrimitive(pModel->GetPrimitive(pos));

					//cópia por reflexao em y (para desenhar o 3 quadrante)
					po_line = (CLevLine *)pModel->GetPrimitive(pos);
					o_line = *po_line;				
					pos = pModel->CreateByReflection(o_line, REFLECTIONYAXIS,opointref, opointref);
					region_downleft.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				}
			}
		}

		if(!is_complete_geometry)
		{
			vpp.clear();
			vpp.push_back(ppxmaxy0);
			vpp.push_back(ppd1);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
				if(has_boundary_lines)
					background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				else
					background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			}

			vpp.clear();
			vpp.push_back(ppd1);
			vpp.push_back(ppd2);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			if(pos >=0 && pos < (signed)pModel->vpPrimitives.size())
				region_right.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			
			vpp.clear();
			vpp.push_back(ppx0ymax);
			vpp.push_back(ppd3);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			if(pos >=0 && pos < (signed)pModel->vpPrimitives.size()) {
				if(has_boundary_lines)
					background_region_ext.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				else
					background_region.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			}

			vpp.clear();
			vpp.push_back(ppd3);
			vpp.push_back(ppd4);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			if(pos >=0 && pos < (signed)pModel->vpPrimitives.size())
				region_top.IncludeNextPrimitive(pModel->GetPrimitive(pos));
		}
	}
}


void CPCFPreProcessor::SetPMLDim(double dd1, double dd2, double dd3, double dd4)
{
	d1 = dd1; if(d1<0) d1 = 0;
	d2 = dd2; if(d2<0) d2 = 0;
	d3 = dd3; if(d3<0) d3 = 0;
	d4 = dd4; if(d4<0) d4 = 0;

	if(d1>0 || d2>0 || d3>0 || d4>0)
		has_pml_lines = true;
}

void CPCFPreProcessor::SetPMLMaterial(int mr1, int mr2, int mr3, int mr4)
{
	mat_r1 = mr1;
	mat_r2 = mr2;
	mat_r3 = mr3;
	mat_r4 = mr4;
}
	
void CPCFPreProcessor::GetPMLDim(double &dd1, double &dd2, double &dd3, double &dd4)
{
	dd1 = d1;
	dd1 = d2;
	dd1 = d3;
	dd1 = d4;

}
void CPCFPreProcessor::GetPMLMaterial(int &mr1, int &mr2, int &mr3, int &mr4)
{
	mr1 = mat_r1;
	mr2 = mat_r2;
	mr3 = mat_r3;
	mr4 = mat_r4;
}
	
void CPCFPreProcessor::HasPMLLines(bool b)
{
	has_pml_lines = b;
}

bool CPCFPreProcessor::HasPMLLines(void)
{
	return has_pml_lines;
}


#if 0 //backup: trata completa e 1/4 na mesma função
void CPCFPreProcessor::IncludeUpdatePitchQuarterGeometry(void)
{
	int				i,j,pos, pos_reg;
	int				num_camadas, num_sub_camadas, num_camadas_anterior;
	int				num_predis_points, num_predis_points_half;
	double			deltax,deltay,centerx, centery, centerx1, centery1;
	double			xaxis, yaxis;	
	double			resto;
	CLevPoint		opointref;// "ponto clicado" para os dados de pré-discretização
	CLevPoint		opointref_reg;//ponto que "identifica" uma região
	double			coeficiente_angular=0, coeficiente_linear;

	double			diametro_ultima_camada;

	CLevLine		oline;
	vpCLevPoint		vpp;
	CLevEllipse		o_elipse, *po_elipse;
	CLevLine		o_line;
	CLevRegion		o_region_holes;
	long			mat_index;

	int p;

	opointref.X(0.);
	opointref.Y(0.);

	deltax = sin(-10.47197551196597742)* pitch.X();
	deltay = 0.5 * pitch.Y();

	vpPointsX.clear();
	vpPointsY.clear();
	
	xcmax = 0;
	ycmax_of_xcmax = 0;

	pcentral.X(0);
	pcentral.Y(0);

	vpHoles.clear();
	vpBoundaryLines.clear();

	if(!is_complete_geometry)
		ppcentral = pModel->Include(pcentral);

	if(central_hole.X() && central_hole.Y()) 
	{
		num_predis_points = vpcfLayers[0].layer_data.PredisPoints();
		if(is_complete_geometry)
		{
			pos = pModel->Include(0.0,0.0,central_hole.X()/2,central_hole.Y()/2,0.0,0.0);
			pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);

			o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));

			mat_index = vpcfLayers[0].layer_data.Material();
			if(mat_index >=0)
			{
				pos_reg = pModel->IncludeRegion(o_region_holes);
				opointref_reg.X(0);
				opointref_reg.Y(0);
				pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
			}

		}
		else //1/4 geometry
		{
			pos = pModel->Include(0.0,0.0,central_hole.X(),central_hole.Y(),0.0,90.0);
			if(num_predis_points/4 > 3) num_predis_points_half = num_predis_points/4;
			else num_predis_points_half = 4;
			pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);
			//inserção das linhas 
			vpp.clear();
			vpp.push_back(ppcentral);
			vpp.push_back(vpPointsY[0]);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);
	//		vpBoundaryLines.push_back(pModel->GetPrimitive(pos));

			vpp.clear();
			vpp.push_back(ppcentral);
			vpp.push_back(vpPointsX[0]);
			oline.SetPoints(vpp);
			pos = pModel->Include(oline);
			pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);
	//		vpBoundaryLines.push_back(pModel->GetPrimitive(pos));
			vpPointsX.push_back(pModel->GetPrimitive(pos)->vpPoints[0]);
			vpPointsY.push_back(pModel->GetPrimitive(pos)->vpPoints[1]);		
		}

//		vpHoles.push_back(pModel->GetPrimitive(pos));
	}//	if(central_hole.X() && central_hole.Y()) 

	num_camadas_anterior = 0;
	//para todas as camadas
	num_camadas = vpcfLayers.size();
	for(p=0;p<num_camadas;p++)
	{
		xaxis = vpcfLayers[p].layer_data.diameters.X()/2.;
		yaxis = vpcfLayers[p].layer_data.diameters.Y()/2.;
		num_sub_camadas = vpcfLayers[p].layer_data.SubLayersNumber();
		num_predis_points = vpcfLayers[p].layer_data.PredisPoints();

		mat_index = vpcfLayers[p].layer_data.Material();

		for(i=1;i<=num_sub_camadas;i++)	
		{	
			centerx = (num_camadas_anterior+i)*deltax;
			centery = (num_camadas_anterior+i)*deltay;
			pos = pModel->Include(centerx,centery,xaxis,yaxis,0.0,0.0);
			o_region_holes.Reinitialize();
			o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
			if(mat_index >=0)
			{
				pos_reg = pModel->IncludeRegion(o_region_holes);
				opointref_reg.X(centerx);
				opointref_reg.Y(centery);
				pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
			}

			pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);
			
			if(is_complete_geometry)
			{
				po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
				o_elipse = *po_elipse;				

				//cópia por reflexao em y (para desenhar o 2 quadrante)
				pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
				o_region_holes.Reinitialize();
				o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				if(mat_index >=0)
				{
					pos_reg = pModel->IncludeRegion(o_region_holes);
					opointref_reg.X(centerx);
					opointref_reg.Y(centery);
					pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
				}

				//cópia por reflexao em x (para desenhar o 4 quadrante)
				pos = pModel->CreateByReflection(o_elipse, REFLECTIONXAXIS,opointref, opointref);
				o_region_holes.Reinitialize();
				o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				if(mat_index >=0)
				{
					pos_reg = pModel->IncludeRegion(o_region_holes);
					opointref_reg.X(centerx);
					opointref_reg.Y(centery);
					pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
				}

				//cópia por reflexao em y (para desenhar o 3 quadrante)
				po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
				o_elipse = *po_elipse;				
				pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
				o_region_holes.Reinitialize();
				o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
				if(mat_index >=0)
				{
					pos_reg = pModel->IncludeRegion(o_region_holes);
					opointref_reg.X(centerx);
					opointref_reg.Y(centery);
					pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
				}
			}

			xcmax= centerx;
			ycmax_of_xcmax= centery;
		
			for(j=1;j<=(num_camadas_anterior+i);j++)
			{
				centerx = ((num_camadas_anterior+i)*deltax) - (j* (deltax));
				centery = (num_camadas_anterior+i)*deltay + j* deltay ; 

				if(centerx == 0.0)// furos na vertical
				{
					if(is_complete_geometry)
					{
						pos = pModel->Include(centerx,centery,xaxis,yaxis,0.0,0.0);
						pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >=0)
						{
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}

						po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
						o_elipse = *po_elipse;				

						//cópia por reflexao em x 
						pos = pModel->CreateByReflection(o_elipse, REFLECTIONXAXIS,opointref, opointref);
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >=0)
						{
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}

					}
					else
					{
						pos = pModel->Include(centerx,centery,xaxis,yaxis,270.0,90.0);

						num_predis_points_half = num_predis_points;
						pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);

						vpp.clear();
						vpp.push_back(pModel->GetPrimitive(pos)->vpPoints[0]);
						vpp.push_back(pModel->GetPrimitive(pos)->vpPoints[1]);
						oline.SetPoints(vpp);
						pos = pModel->Include(oline);
						
						vpPointsY.push_back(pModel->GetPrimitive(pos)->vpPoints[0]);
						vpPointsY.push_back(pModel->GetPrimitive(pos)->vpPoints[1]);
						pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);						
					}
											
					if(centery > ycmax) ycmax = centery;

				}
				else
				{
					pos = pModel->Include(centerx,centery,xaxis,yaxis,0.0,0.0);
					pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);
					o_region_holes.Reinitialize();
					o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					if(mat_index >=0)
					{
						pos_reg = pModel->IncludeRegion(o_region_holes);
						opointref_reg.X(centerx);
						opointref_reg.Y(centery);
						pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
					}

					if(centerx > xcmax && centery > ycmax_of_xcmax)
					{
						xcmax= centerx;
						ycmax_of_xcmax= centery;
					}

					if(is_complete_geometry)
					{
						po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
						o_elipse = *po_elipse;				

						//cópia por reflexao em y (para desenhar o 2 quadrante)
						pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >=0)
						{
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}

						//cópia por reflexao em x (para desenhar o 4 quadrante)
						pos = pModel->CreateByReflection(o_elipse, REFLECTIONXAXIS,opointref, opointref);
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >=0)
						{
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}
						//cópia por reflexao em y (para desenhar o 3 quadrante)
						po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
						o_elipse = *po_elipse;				
						pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >=0)
						{
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}
					}
				}
				centerx1 = ((num_camadas_anterior+i)*deltax);
				centery1 = ((num_camadas_anterior+i)*deltay)- ((2*j)* deltay);

				resto = (num_camadas_anterior+i)%2;
				if (centery1 == 0.0 && resto==0.0) // furos na horizontal
				{
					if(is_complete_geometry)
					{
						pos = pModel->Include(centerx1,centery1,xaxis,yaxis,0.0,0.0);
						pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >=0)
						{
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}

						po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
						o_elipse = *po_elipse;				

						//cópia por reflexao em y 
						pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >=0)
						{
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}

					}
					else
					{
						pos = pModel->Include(centerx1,centery1,xaxis,yaxis,0.0,180.0);
						num_predis_points_half=num_predis_points;
						pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);

						vpPointsX.push_back(pModel->GetPrimitive(pos)->vpPoints[1]);
						vpPointsX.push_back(pModel->GetPrimitive(pos)->vpPoints[0]);

						vpp.clear();
						vpp.push_back(pModel->GetPrimitive(pos)->vpPoints[0]);
						vpp.push_back(pModel->GetPrimitive(pos)->vpPoints[1]);
						oline.SetPoints(vpp);
						pos = pModel->Include(oline);
						
						pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points_half,1,opointref);
					}
				}

				if(centery1 != 0.0 && centery1> 0.0)
				{
					pos = pModel->Include(centerx1,centery1,xaxis,yaxis,0.0,0.0);
					pModel->GetPrimitive(pos)->SetPreDiscretizationData(num_predis_points,1,opointref);					
					o_region_holes.Reinitialize();
					o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
					if(mat_index >=0)
					{
						pos_reg = pModel->IncludeRegion(o_region_holes);
						opointref_reg.X(centerx);
						opointref_reg.Y(centery);
						pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
					}
										
					if(centerx > xcmax && centery > ycmax_of_xcmax)
					{
						xcmax= centerx1;
						ycmax_of_xcmax= centery1;
					}

					if(is_complete_geometry)
					{
						po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
						o_elipse = *po_elipse;				

						//cópia por reflexao em y (para desenhar o 2 quadrante)
						pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >=0)
						{
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}

						//cópia por reflexao em x (para desenhar o 4 quadrante)
						pos = pModel->CreateByReflection(o_elipse, REFLECTIONXAXIS,opointref, opointref);
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >=0)
						{
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}

						//cópia por reflexao em y (para desenhar o 3 quadrante)
						po_elipse = (CLevEllipse *)pModel->GetPrimitive(pos);
						o_elipse = *po_elipse;				
						pos = pModel->CreateByReflection(o_elipse, REFLECTIONYAXIS,opointref, opointref);
						o_region_holes.Reinitialize();
						o_region_holes.IncludeNextPrimitive(pModel->GetPrimitive(pos));
						if(mat_index >=0)
						{
							pos_reg = pModel->IncludeRegion(o_region_holes);
							opointref_reg.X(centerx);
							opointref_reg.Y(centery);
							pPhysData->AssociateMaterialToRegion(pos_reg, mat_index,opointref_reg, 0.0);
						}
					}
				}
			}
		}

		num_camadas_anterior = num_camadas_anterior + num_sub_camadas;
	}

	//insere linhas 
	diametro_ultima_camada = vpcfLayers[vpcfLayers.size()-1].layer_data.diameters.X();
	//calcula ponto extremo ymax em x=0

	if(has_boundary_lines || !d1 || (!d1&&!d2))
		xmax = xcmax + 3*diametro_ultima_camada/4;
	else 
		xmax = xcmax + diametro_ultima_camada/2;

	if(has_boundary_lines || !d3 || (!d3&&!d4))
		ymax = ycmax + diametro_ultima_camada/2+ diametro_ultima_camada/4;
	else 
		ymax = ycmax +  diametro_ultima_camada/2;

	//coeficiente angular da reta que passa pelos centros dos furos da ultima camada
	coeficiente_angular = (ycmax - ycmax_of_xcmax)/(- xcmax);
	coeficiente_linear = ymax;
	ymax_of_xmax = coeficiente_angular*xmax + coeficiente_linear;

}//void CPCFPreProcessor::IncludeUpdatePitchQuarterGeometry(void)
#endif
